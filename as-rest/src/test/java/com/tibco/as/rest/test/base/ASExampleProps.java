// -------------------------------------------------------------------
//  Copyright (c) 2012-2013 TIBCO Software, Inc.
//  All rights reserved.
//  For more information, please contact:
//  TIBCO Software Inc., Palo Alto, California, USA
// -------------------------------------------------------------------
package com.tibco.as.rest.test.base;

import java.util.Properties;

public class ASExampleProps
{
    public static String METASPACE_HELP = "\nUsage:"
            + "\n\t[-help]                              display command line options"
            // Metaspace and MemberDef settings
            + "\n\t[-metaspace <string>]                metaspace name, default=ms"
            + "\n\t[-member_name <string>]              unique member name, default=autogenerated name"
            + "\n\t[-discovery <string>]                discovery url, default=tibpgm"
            + "\n\t[-listen <string>]                   listen url, default=tcp"
            + "\n\t[-remote_listen <string>]            remote listen url"
            + "\n\t[-rx_buffer_size <string>]           size of receive buffer to use for each transport connection"
            + "\n\t[-transport_thread_count <string>]   number of threads to use for transport communication"
            + "\n\t[-data_store <string>]               data store path";

    public static String METASPACE_SECURITY_HELP = ""
            + "\n\t[-security_policy <string>]          security policy path"
            + "\n\t[-security_token <string>]           security token path";

    public static String SPACE_HELP = ""
            + "\n\t[-space <string>]                    space name, default=myspace"
            // Space and SpaceMemberDef settings
            + "\n\t[-role <string>]                     distribution role (leech | seeder ), default=leech"
            // SpaceDef settings
            + "\n\t[-distribution_policy <string>]      distribution policy (distributed | non-distributed), default=distributed"
            + "\n\t[-replication_policy <string>]       replication policy, (async | sync), default=async"
            + "\n\t[-replication_count <string>]        number of times to replicate the space data, default=0"
            + "\n\t[-persistence <string>]              persistence type (none | shared_nothing | shared_all), default=none"
            + "\n\t[-persitence_policy <string>]        persistence policy (async | sync), default=async"
            + "\n\t[-capacity <string>]                 max number of entries per seeder, default=-1 (infinite)"
            + "\n\t[-eviction_policy <string>]          eviction policy (none | lru), default=none"
            + "\n\t[-host_aware_replication <string>]   enable multi-level hashing (true | false), default=true"
            + "\n\t[-routed <string>]                   enable routing (true | false), default=false"
            + "\n\t[-min_seeders <string>]              minimum number of seeders required for space"
            + "\n\t[-encrypt_field]                     add an encrypted field to the space";

    public static String BASE_HELP = METASPACE_HELP + METASPACE_SECURITY_HELP + SPACE_HELP;

    static final String baseCommands[] =
    {
            "-help", "-metaspace", "-member_name", "-discovery", "-listen",
            "-remote_listen", "-rx_buffer_size", "-transport_thread_count",
            "-data_store", "-security_policy", "-security_token",
            "-space", "-role", "-distribution_policy",
            "-replication_policy", "-replication_count",
            "-persistence", "-persistence_policy",
            "-capacity", "-eviction_policy", "-min_seeders",
            "-host_aware_replication", "-routed"
    };

    static final String metaspaceCommands[] =
    {
            "-help", "-metaspace", "-member_name", "-discovery", "-listen",
            "-remote_listen", "-rx_buffer_size", "-transport_thread_count",
            "-data_store"
    };

    static final String metaspaceSecurityCommands[] =
    {
        "-security_policy", "-security_token"
    };

    static final String spaceCommands[] =
    {
            "-space", "-role", "-distribution_policy",
            "-replication_policy", "-replication_count",
            "-persistence", "-persistence_policy",
            "-capacity", "-eviction_policy", "-min_seeders",
            "-host_aware_replication"
    };

    Properties properties = new Properties();
    String allowedCommands[] = null;
    String commandLineArgs[] = null;
    String additionalCommands[] = null;
    String specialCommands[] = {"-encrypt_field"};
    protected String defaultSpaceName = "myspace";

    public ASExampleProps ()
    {
        // default to allowing the full set of basic command line arguments
        allowedCommands = baseCommands;
    }

    /**
     * Called once to save the example's command line arguments for later
     * parsing.
     *
     * @param args
     *            The example's command line arguments.
     */
    public void setCommandLineArgs (String[] args)
    {
        // save the command line arguments for later parsing
        if (args != null)
            commandLineArgs = args;
    }

    public void allowMetaspaceCommands ()
    {
        allowedCommands = metaspaceCommands;
        BASE_HELP = METASPACE_HELP;
    }

    /**
     * Allows the examples to specify additional command line arguments which
     * should be allowed.
     *
     * @param addCommands
     *            An array of strings which contains the additional commands to
     *            allow.
     */
    public void allowAdditionalCommands (String[] commands)
    {
        if (commands != null)
        {
            additionalCommands = commands;
        }
    }

    public void allowSpecialCommands (String[] commands)
    {
        if (commands != null)
        {
            if (specialCommands == null)
                specialCommands = commands;  // use given commands
            else
            {
                int sclen = specialCommands.length + commands.length;
                // make a copy of our current specialCommands
                String[] tempCommands = new String[specialCommands.length];
                System.arraycopy(specialCommands, 0, tempCommands, 0, specialCommands.length);
                // now combine both arrays of commands back into specialCommands array
                specialCommands = new String[sclen];
                System.arraycopy(tempCommands, 0, specialCommands, 0, tempCommands.length);
                System.arraycopy(commands, 0, specialCommands, tempCommands.length, commands.length);
            }
        }
    }

    /**
     * Verify the example's command line arguments and store their values for
     * later use.
     *
     * @param args
     *            The example programs command line arguments.
     */
    public void parseArgs ()
    {
        String[] args = commandLineArgs;

        for (int i = 0; i < args.length; i += 2)
        {
            String key = args[i];
            String value = null;
            boolean checkValue = true;
            if (key.equals("-help") || key.equals("-h") || key.equals("?"))
            {
                help();
                System.exit(0);
            }
            if (!checkCommandArg(key))
            {
                if (!checkSpecialArg(key))
                {
                    System.out.println("Invalid command line argument: " + key);
                    help();
                    System.exit(1);
                }
                else
                {
                    checkValue = false;
                    value = "true"; // we have a command line argument without a
                                    // value, so set the value to true
                    i = i - 1;      // backup the value of i since 2 will be added
                                    // to it but we didn't read 2 command line arguments
                }
            }

            if (checkValue && (i + 1 == args.length))
            {
                System.out.println("Missing value for command line argument: "
                        + key);
                help();
                System.exit(1);
            }
            if (checkValue)
                value = args[i + 1];
            properties.put(key, value);
        }
        // Determine the default space name to use based upon the command line
        // arguments.
        setSpaceName();
    }

    /**
     * Displays the possible command line arguments that can be passed to the
     * running example.
     */
    public void help ()
    {
        System.out.println(getClass().getName() + " " + BASE_HELP);
    }

    /**
     * Retrieves the stored value of the given command line argument.
     *
     * @param arg
     *            The command line argument to find the stored value of.
     * @param propertyDefault
     *            Default value to use if no value is stored for the command
     *            line argument.
     * @return The stored value of the command line argument.
     */
    public String getProperty (String arg, String propertyDefault)
    {
        if (arg == null)
            return propertyDefault;
        String val = properties.getProperty(arg, propertyDefault);
        return val;
    }

    /**
     * Stores the given command line argument and its value.
     *
     * @param arg
     *            The command line argument to store.
     * @param val
     *            The value to associate with the given command line argument.
     */
    public void setProperty (String arg, String val)
    {
        if (checkCommandArg(arg))
            properties.setProperty(arg, val);
        else
            System.out.println("Invalid command line argument: " + arg);
    }

    /**
     * Check to make sure the given command line argument is allowed.
     *
     * @param arg
     *            A command line argument.
     * @return true if the given argument is valid, false otherwise.
     */
    public boolean checkCommandArg (String arg)
    {
        if (arg == null)
            return false;

        boolean found = false;
        for (int i = 0; i < allowedCommands.length; i++)
        {
            if (allowedCommands[i].equals(arg))
            {
                found = true;
                break;
            }
        }
        if (!found && additionalCommands != null)
        {
            for (int j = 0; j < additionalCommands.length; j++)
            {
                if (additionalCommands[j].equals(arg))
                {
                    found = true;
                    break;
                }
            }
        }
        return found;
    }

    /**
     * Check to see if this is a special command line argument which does not
     * take a value.
     *
     * @param arg
     *            A command line argument.
     * @return true if the given argument is valid, false otherwise.
     */
    public boolean checkSpecialArg (String arg)
    {
        if (arg == null)
            return false;
        if (specialCommands == null)
            return false;
        boolean found = false;
        for (int i = 0; i < specialCommands.length; i++)
        {
            if (specialCommands[i].equals(arg))
            {
                found = true;
                break;
            }
        }
        return found;
    }

    /**
     * Determine the default space name to use based upon the parsed command
     * line arguments.
     */
    public void setSpaceName ()
    {
        // Some of the examples use a different space name, so we need to adjust
        // the default space name. An example will use a different space name
        // to identify when a different space definition is being used. This helps
        // to prevent SpaceDef mismatch errors. For example, the persistence examples
        // set the space name based upon the type of persistence since the space
        // definitions for each type of persistence are slightly different
        // from the space definition used by the examples normally.
        // Setting the space name on the command line using the -space option
        // will always override the default space name setting.
        String persistenceType = properties.getProperty("-persistence", "");
        if (!persistenceType.isEmpty())
        {
            if (persistenceType.equalsIgnoreCase("shared_nothing"))
                defaultSpaceName = "shared_nothing_persisted";
            else if (persistenceType.equalsIgnoreCase("shared_all"))
                defaultSpaceName = "shared_all_persisted";
        }
    }
}
